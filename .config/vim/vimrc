"
" vim: fdm=marker

"Vim-plug {{{
call plug#begin()

if !has("nvim")
	Plug 'tpope/vim-sensible'                                        " Sensible default if not nvim
endif

" Plug 'vim-pandoc/vim-rmarkdown'                                      " Pandoc + rmarkdown
Plug 'chrisbra/Colorizer',            {'on':'ColorToggle'}           " Highlight #COLORS
Plug 'chrisbra/csv.vim',              {'for':'csv'}                  " Csv file support
Plug 'fretep/todo.txt-vim',           {'for':'todo'}                 " Todo.txt support
Plug 'godlygeek/tabular'                                             " Tabularize
Plug 'junegunn/fzf',	{ 'dir': '~/.fzf', 'do': './install --all' } " Fzf <3
Plug 'junegunn/goyo.vim'                                             " Distraction free writing
Plug 'mbbill/undotree'                                               " Visualize undo tree
Plug 'paroxayte/autocd.vim'                                          " Autocd in folder rule-based
Plug 'rickhowe/diffchar.vim'                                         " Better highlighting in diff mode
Plug 'sheerun/vim-polyglot'                                          " A collection of language pack
Plug 'tpope/vim-commentary'                                          " Comment done right
Plug 'tpope/vim-surround'                                            " Surrounding motions on steroid
Plug 'vim-pandoc/vim-pandoc', {'for':'pandoc'}                       " Pandoc integration
Plug 'vim-pandoc/vim-pandoc-syntax',                                 " Pandoc syntax
call plug#end()
" }}}

" Options {{{
filetype plugin indent on                " Specific indentation rules depending on file type
filetype plugin on                       " Filetype plugin
syntax enable                            " Enable syntax Highlighting
set autoindent                           " Auto-inden
set autoread                             " Auto reload file if modified from external command
set backupdir=~/.local/share/nvim/backup// " Backup file in /tmp//
set breakindent                          " Indent word wrapped line as much as parent line
set colorcolumn=+1                       " Highlight 81/th column
set cursorline                           " Highlight the line in which the cursor is
set directory^=~/.local/share/nvim/swap//  " Where to save swp file
set foldmethod=syntax                    " Fold according to syntax
set hidden                               " Allow to switch buffer without saving it
set hlsearch                             " Highlight all search results
set writebackup                          " Write backup file before saving buffer to disk, delete after success
set incsearch                            " Incremental search
set ignorecase                           " Ignore case when search
set noexpandtab                          " On pressing tab, insert \t. If set, convert tab in tabstop spaces
set laststatus=2                         " 1 ⇒ statusbar only if > 2 windows; 2 ⇒ always
set lazyredraw                           " Redraw screen only when really necessary
set linebreak                            " Break long lines at spaces, not in the middle of a word
set modeline                             " Vim executes vimL commands if they are found in the current file
set mouse=a                              " Enable mouse in all (=a) modes
set noautochdir                          " Do not change folder
set noshowmode                           " Not show when in insert mode
set number relativenumber                " Line numbers are relative to current line
set omnifunc=syntaxcomplete#Complete     " Omni-completion
set path^=**                             " Recursive file search starting from current dir
set secure                               " No shell command on autocmd
set shiftwidth=0                         " Indent following tabstop
set scrolloff=8                          " Lines to keep above and below while scrolling
set showcmd                              " Show partially typed commands
set smartcase                            " Smart-case search
set smartindent                          " Smart indent
set spell                                " Spelling on
set spelllang=it,en                      " Spell dictionaries
set splitbelow                           " HSplit below
set splitright                           " Vsplit to the right
set swapfile                             " Always create swp file
set tabstop=4                            " Tab is up to this much  |	|
set undodir=~/.local/share/nvim/undo//   " Where to save persistent undo history
set undofile                             " Persistent history
set undolevels=5000                      " How many edit are saved in undofile
set updatetime=2000                      " Consider vim inactive after x sec of no activity in normal mode
set wildignorecase                       " Ignore case when autocomplete
set wildmenu                             " Tab autocompletion in menu
let mapleader = " "
let maplocalleader = " "
if has("nvim")
	set inccommand=nosplit
endif
"}}}

" Plugin settings {{{

" Netrw
let g:netrw_altv = 1            " split to the right
let g:netrw_banner = 1          " banner (with help)
let g:netrw_browse_split = 0    " open buffer in current window
let g:netrw_list_hide = netrw_gitignore#Hide()
let g:netrw_liststyle = 0       " buffer view

" Pandoc
let g:pandoc#biblio#bibs = ["/home/vic/pCloudDrive/Uni/Med-Notes/bib.bib"]
let g:pandoc#biblio#use_bibtool = 1
let g:pandoc#folding#fastfolds = 1
let g:pandoc#folding#fdc = 0
let g:pandoc#folding#level = 0
let g:pandoc#modules#disabled = [""]
let g:pandoc#syntax#conceal#use = 0
let g:pandoc#toc#close_after_navigating = 1
let g:pandoc#toc#position = "left"
let g:pandoc#toc#shift = 4

" Fzf
let g:fzf_action = {
	\ 'ctrl-t': 'tab split',
	\ 'ctrl-h': 'split',
	\ 'ctrl-v': 'vsplit' }

" Autocd
let g:autocd#autocmd_enable = 1
let g:autocd#markers = { '**/Medicina/**/*.txt': ['Makefile'] }

" Csv
let g:csv_highlight_column = 'y'
" }}}

" Mappings {{{
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap Q q
cnoremap W w
cnoremap X x
inoremap  =system("date")<CR><Esc>kJ$x
inoremap <C-z> <C-o><C-z>
inoremap <F1> <Esc>
noremap '' :b#<CR>
noremap '. :FZF<CR>
noremap 'b :Buffers<CR>
noremap 'f :FZF --no-exact 
noremap 'h :FZF %:h <CR>
noremap 't :FZF<CR>
noremap 'u :FZF $UNI<CR>
noremap <BS> -
noremap <C-l> :noh<CR>
noremap <C-n> :cn<CR>
noremap <C-p> :cp<CR>
noremap <F1> <Esc>
noremap <F8> :se spell!<CR>
noremap <F9> :se nowrap!<CR>
noremap <leader>so :!mimeopen "%" <CR>
noremap Y y$
noremap Z zMzv
noremap j gj
noremap k gk
vnoremap J gj
vnoremap K gk
vnoremap az [zo]z
vnoremap iz [zjo]zk
if has("nvim")
	tnoremap <C-\> <C-\><C-n>
endif
" }}}

" Abbreviations and digraphs {{{
iabbrev Perchè Perché
iabbrev ab ab.
iabbrev perchè perché
iabbrev pz pz.
iabbrev sg sg.
iabbrev tp tp.
dig lt 0060 " Digraph <
dig gt 0062 " Digraph >
dig ra 8594 " Digraph →
dig Ra 8658 " Digraph ⇒
dig Ba 8656 " Digraph ⇐
dig le 8804 " Digraph ࣘࣘࣘ≤
dig ge 8805 " Digraph ≥

" }}}

" Extended text Objects and matchpairs {{{
" Thanks to Conner McDaniel: https://youtu.be/0F4FgiVWvB8
set matchpairs+=<:>
let s:items = [ ",", "." , "-" , "_" , "*" , ":" , "/" , "<bar>", "+", "\\", "^", "~"]
for item in s:items
	" exe "noremap yi".item." T".item."yt".item
	" exe "noremap ya".item." F".item."yf".item
	" exe "noremap ci".item." T".item."ct".item
	" exe "noremap ca".item." F".item."cf".item
	" exe "noremap di".item." T".item."dt".item
	" exe "noremap da".item." F".item."df".item
	" exe "vnoremap vi".item." T".item."vt".item
	" exe "vnoremap va".item." F".item."vf".item
	" Same thing
	exe "omap i".item ":<C-U>normal!vT".item."ot".item."<CR>"
	exe "omap a".item ":<C-U>normal!vF".item."of".item."<CR>"
endfor
" }}}

" Autogroups and Autocmds {{{
autocmd CursorHold * silent! update " Autosave the buffer if on hold > updatetime ms (normal mode only)

autocmd! BufWritePost *vimrc* source %

if has('nvim') && !exists('g:fzf_layout')
	autocmd! FileType fzf
	autocmd  FileType fzf setlocal laststatus=0 noruler norelativenumber
		\| autocmd BufLeave <buffer> set laststatus=2 ruler relativenumber
endif

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

augroup pandoc
	autocmd BufNewFile,BufRead,BufWrite *.txt,*.md set ft=pandoc
augroup end

augroup todotxt
	autocmd bufNewfile,bufRead,bufWrite *todo.txt setl ft=todo | set nospell | se nowrap
	autocmd bufNewfile,bufRead,bufWrite *done.txt setl ft=todo | set nospell | se nowrap
augroup end

augroup nonvim
	" BufReadCmd is used because is triggered _before_ the file is red into
	" the buffer, so if the file size is very large it won't freeze vim until
	" the file is loaded into the buffer -- which we'll not use anyway
	autocmd BufReadCmd *.{png,jpg,pdf,gif,scpt,doc,docx,odt,ppt,pptx,odp,xlsx,xls,ods,mp3,mp4,mov,mkv} sil! exe "!xdg-open " . shellescape(expand("%:p")) . " &" | bd | let &ft=&ft | redraw!
augroup end


augroup man
	autocmd BufNewFile,BufRead,BufReadCmd man://* set laststatus=0
augroup end
" }}}

" Functions {{{

" Goyo
function! s:goyo_enter()
	" vertical resize
	silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
	set scrolloff=999
	if &bg == "light"
		hi NonText ctermfg=15 ctermbg=NONE
		hi Whitespace ctermfg=NONE ctermbg=NONE
		hi EndOfBuffer ctermfg=15 ctermfg=NONE
	endif
endfunction

function! s:goyo_leave()
	silent! source ~/.config/nvim/init.vim
	set scrolloff=0
	set noshowmode
	let &bg=&bg
endfunction

" Diff from current buffer against saved file
function! s:DiffWithSaved()
	let filetype=&ft
	diffthis
	vnew | r # | normal! 1Gdd
	diffthis
	exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
com! DiffSaved call s:DiffWithSaved()

command! -nargs=? Files FZF --query=<args>\ 

" Now :ls <3 fzf
function! s:buflist()
	redir => ls
	silent ls
	redir END
	return split(ls, '\n')
endfunction

function! s:bufopen(e)
	execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

command! -nargs=* Buffers call fzf#run(fzf#wrap({
	\   'source':  reverse(<sid>buflist()),
	\   'sink':    function('<sid>bufopen'),
	\   'options': '--no-exact +m --query="<f-args>"',
	\   'down':    len(<sid>buflist()) + 4
	\ }))


" fzf search :oldfiles
command! -bang MRU call fzf#run(fzf#wrap({
	\   "source": v:oldfiles,
	\}, <bang>0))
" }}}

" Notes {{{
command! -nargs=1 Nack vimgrep "<args>" $MED_CURRENT/**/*.md
nnoremap <leader>n :Nack 
" }}}

" Appearance and statusline {{{
set list listchars=tab:·\ ,trail:·,eol:¬,extends:→,precedes:← " Non printable chars
set fillchars=vert:\ ,fold:\ 
set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50    " Different cursor shape in different mode
let &bg=$BG    " Light|dark, exported in .bashrc

colorscheme dimim

" Statusline
function! CurrentMode()
	" Current mode
	let currentMode = mode()

	" Custom names
	let modes = {
		\ 'c'  : 'COMMAND',
		\ 'i'  : 'INSERT',
		\ 'n'  : 'NORMAL',
		\ 'R'  : 'REPLACE',
		\ 't'  : 'TERM',
		\ 'v'  : 'VISUAL',
		\ 'V'  : 'V-LINE',
		\ '' : 'V-BLOCK',
		\ }

	" Mode color
	if (currentMode =~# 'n' )
		let color = "10"
	elseif (currentMode =~# 'i')
		let color = "9"
	elseif (currentMode =~# 'v\|V\|\')
		let color = "12"
	elseif (currentMode =~# 't')
		let color = "11"
	elseif (currentMode =~# 's\|R')
		let color = "14"
	elseif (currentMode =~# 'c')
		let color = "13"
	else
		let color="7"
	endif

	exe "hi! User2 ctermfg=0 ctermbg=".color." cterm=bold"
	return modes[currentMode]
endfunction

" Draw a small rectangle indicating if there are pending task in my
" todo manager
function! TaskIndicator()
	if ($TMUX == "")
		let color = 2     " Green if everything is done
		let urgentTask = system("todo urgent | wc -l")
		let todayTask = system("todo ls | wc -l")
		if (urgentTask > 0)
			let color = 1 " Red if urgent task is pending
		elseif (todayTask > 0)
			let color = 3 " Yellow if normal task is pending
		endif
		exe "hi! User3 ctermfg=0 ctermbg=".color
		redrawstatus
		return "  "
	else
		redrawstatus
		return ""
	endif
endfunction

set stl=%2*\ %{CurrentMode()}\ %0*\ \ %t%<\ %=\ %m%r%h%w\ \|\ %Y\ \|\ Ln\ %l/%L,\ Col\ %v\ (%p%%)\ \|\ %{strftime('%H:%M')}\ %3*%{TaskIndicator()}

" }}}
